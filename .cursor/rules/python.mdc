---
description: Python best practices and patterns for modern software development with Flask and SQLite
globs: **/*.py, src/**/*.py, tests/**/*.py
---

# Python Best Practices

## Project Structure
- Use src-layout with `src/your_package_name/`
- Place tests in `tests/` directory parallel to `src/`
- Keep configuration in `config/` or as environment variables
- Store requirements in `requirements.txt` or `pyproject.toml`
- Place static files in `static/` directory
- Use `templates/` for Jinja2 templates

## Code Style
- Follow Black code formatting
- Use isort for import sorting
- Follow PEP 8 naming conventions:
  - snake_case for functions and variables
  - PascalCase for classes
  - UPPER_CASE for constants
- Maximum line length of 88 characters (Black default)
- Use absolute imports over relative imports

## Type Hints
- Use type hints for all function parameters and returns
- Use type hints for variables at their first declaration in functions as well
- Import types from `typing` module
- Use `Optional[Type]` instead of `Type | None`
- Use `TypeVar` for generic types
- Use `Protocol` for duck typing
- Use `-> None` type hinting for functions with no return value
- You MUST AVOID untyped definitions like: `List`, `Dict`, try to add the most adequate type hints
- Please be mindful that not following proper type hinting can lead to severe hallucinations from your part, therefore you must avoid it at all cost

### Bad function typing example
```python
def random_function(input_dict: dict) -> List: ...# I do not know what the List contains, and know even less about the parameter dictionary
def random_function2(input_list: list) -> Dict: ...
```

### Bad variable definition
```python
def random_function(input_dict: Dict[str, Any]) -> Dict[str, str]: 
    dict_variable = {} # the dictionary element here is not typed therefore it's content is ambiguous to the linter
    for k, v in input_dict.items():
      dict_variable[v] = k

    return list(dict_variable.keys())
```

## Database handling and migration
- You are NOT allowed to generate migrations by hand, but you may remind the user to do the migrations using alembic functions

## Testing
- Use pytest for testing framework
- Use pytest-cov for coverage reporting
- Use Polyfactory for generating test data and fixtures where necessary
- Implement consistent fixtures with proper separation of concerns
- Organize fixtures under `tests/fixtures/` directory with logical separation:
  - `tests/fixtures/models/` for model-related fixtures
  - `tests/fixtures/api/` for API-related fixtures
  - `tests/fixtures/data/` for data generation fixtures
  - `tests/fixtures/mocks/` for mock-related fixtures
- Use proper mocking with pytest-mock for external dependencies
- Test all error scenarios and edge cases
- Write detailed test descriptions that explain:
  - What aspect of the functionality is being tested
  - Why this test case is important for reliability
  - What specific behavior or edge case is being validated
  - How the test contributes to overall code quality
- Include comprehensive docstrings in test functions explaining the test's purpose and significance
- Use descriptive test names that clearly indicate what is being tested
- Ensure tests are isolated and don't depend on external state
- Implement proper setup and teardown for test data
- Use parameterized tests for testing multiple scenarios efficiently
- Avoid creating meaningless, redundant or unnecessary testcases or testcases that are already proven correct by a previous testcase

## Security
- Use HTTPS in production
- Implement proper CORS
- Sanitize all user inputs
- Use proper session configuration
- Implement proper logging
- Follow OWASP guidelines


## Error Handling
- Create custom exception classes
- Use proper try-except blocks
- Implement proper logging
- Return proper error responses
- Handle edge cases properly
- Use proper error messages

## Documentation
- Use Google-style docstrings with a little bit of twist
- Document all public APIs
- Use proper inline comments that are reflective to the context and hold meaningful information about the 
- If a variable name, a function name or a class name is mentioned in the documentation it should be wrapped in `...` quotations following Markdown standards
- Instead of writing boring flowing text descriptions for function documentation, write it an easy to understand, straight to the point manner
- You are also allowed to use Markdown compatible enumerations in the function or class documentations for easier understanding

A potential good example for the documentation of a `function`:

```python
async def initialize_run(
    self, run_type: str, metadata: Dict[str, Any], existing_run_id: Optional[str] = None
) -> str:
    """Initialize a run with **rich** terminal output.

    Args:
        run_type (str): The type of run that we will use
        metadata (Dict[str, Any]): Dictionary containing relevant metadata to the actual run
        existing_run_id (Optional[str]): Existing run ID for compatibility reasons, but not used in any way

    Returns:
        str: ID of the run that will be generated

    Raises:
        PublisherUnavailableError: If publisher is not available for any reason
    """
    ...
```

Notice that in the example:
- The important parts or words of the textual section of the documentation are **highlighted** following Markdown formatting
- References to other classes are distinguished with `Class` notation
- Every argument is properly typed and is given proper, explanatory description of its role for the function
- Args, Returns, and Raises sections must be provided for each and every function, exception being if there are either no arguments for the function, or it might not raise any error

A potential good example for the documentation of a `class`:

```python
class BugninjaClient:
    """Main entry point for Bugninja browser automation operations.

    This class provides a simple, intuitive interface for:
    - browser automation tasks
    - session replay
    - healing operations.

    It also handles:
    - configuration management
    - error handling
    - comprehensive logging

    Attributes:
        config (Optional[BugninjaConfig]): Optional configuration object for the upcoming tasks for this client.
        This will be the **default configuration** for every `BugninjaTask` executed with this client, if there is **no other configuration specified** in a `BugninjaTask`.
        event_manager (Optional[EventPublisherManager]): Optional event publisher manager for tracking each and every operation happening in each `BugninjaTask`.

    ### Key Methods

    1. *async* **run_task()** -> `BugninjaTaskResult`: - Execute browser automation tasks
    2. *async* **replay_session()** -> `BugninjaTaskResult`: - Replay recorded sessions (with optional healing)
    3. **list_sessions()** -> `List[SessionInfo]`: - List available sessions
    4. *async* **cleanup()**: -> `None` - Clean up resources

    Example:
        /`/`/`python
        from bugninja.api.client import BugninjaClient
        from bugninja.api.models import BugninjaTask

        # Create client with default configuration
        client = BugninjaClient()

        # Execute a simple task
        task = BugninjaTask(description="Navigate to example.com and click login")
        result = await client.run_task(task)

        if result.success:
            print(f"BugninjaTask completed in {result.steps_completed} steps")
        else:
            print(f"BugninjaTask failed: {result.error}")
        /`/`/`
    """
```
Notice that in the example:
- The important parts or words of the textual section of the documentation are **highlighted** following Markdown formatting
- References to other classes are distinguished with `Class` notation
- There is a clear, easy to understand description about the functionality of the class
- If enumerations are present in a description, they are formatted using Markdown formatting
- Both the attributes and the key methods are present in the documentation with proper type annotations 
- The key methods are formatted in a unique and spectacular way
- Every class documentation must have an example included with all the necessary imports as well
- The examples must be syntactically correct and reflect on a potential real usage of the class

